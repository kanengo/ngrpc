package wrr

import (
	"math"
	"sync/atomic"
	"time"

	balancer2 "kanengo.com/nengo/internal/rpc/client/grpc/balancer"

	"kanengo.com/nengo/internal/utils/errors"

	"kanengo.com/nengo/internal/rpc/metadata"
	"kanengo.com/nengo/internal/utils/lock"

	"kanengo.com/nengo/internal/metric"

	"google.golang.org/grpc/balancer"
)

const (
	Name = "nengo-WeightRoundRobin"
)

type wrrPickerBuilder struct{}

func (*wrrPickerBuilder) Build(info balancer2.PickerBuildInfo) balancer.Picker {
	p := &wrrPicker{}
	uid := int64(0)
	for sc := range info.ReadySCs {
		uid++
		_sc := &subConn{
			conn: sc,
			err: metric.NewRollingCounter(metric.RollingCounterOpts{
				Size:           10,
				BucketDuration: time.Millisecond * 100,
			}),
			latency: metric.NewRollingGauge(metric.RollingGaugeOpts{
				Size:           10,
				BucketDuration: time.Millisecond * 100,
			}),
			wt:    10,
			ewt:   10,
			cwt:   0,
			si:    serverInfo{},
			score: -1,
			id:    uid,
		}
		p.subConns = append(p.subConns, _sc)
	}

	return p
}

func newBuilder() balancer.Builder {
	return balancer2.NewBalancerBuilder(Name, &wrrPickerBuilder{}, balancer2.Config{HealthCheck: true})
}

func RegisterBalancer() {
	balancer.Register(newBuilder())
}

type serverInfo struct {
	cpu     int64
	success uint64
}

type subConn struct {
	conn    balancer.SubConn
	err     metric.RollingCounter
	latency metric.RollingGauge
	wt      int64
	ewt     int64
	cwt     int64
	si      serverInfo
	score   float64
	id      int64
}

func (c *subConn) errSummary() (errc int64, reqc int64) {
	c.err.Reduce(func(iterator metric.BucketIterator) float64 {
		for iterator.Next() {
			bucket := iterator.Bucket()
			reqc += bucket.Count
			for _, p := range bucket.Points {
				errc += int64(p)
			}
		}
		return 0
	})
	return
}

func (c *subConn) latencySummary() (latency float64, count int64) {
	c.latency.Reduce(func(iterator metric.BucketIterator) float64 {
		for iterator.Next() {
			bucket := iterator.Bucket()
			count += bucket.Count
			for _, p := range bucket.Points {
				latency += p
			}
		}
		return 0
	})
	return latency / float64(count), count
}

type wrrPicker struct {
	subConns []*subConn
	updateAt int64

	//sync.Mutex
	lock.CasLock
}

func (w *wrrPicker) Pick(info balancer.PickInfo) (balancer.PickResult, error) {
	if len(w.subConns) <= 0 {
		return balancer.PickResult{}, balancer.ErrNoSubConnAvailable
	}
	var (
		conn        *subConn
		totalWeight int64
	)
	w.Lock()
	for _, sc := range w.subConns {
		totalWeight += sc.ewt
		sc.cwt += sc.ewt
		if conn == nil || sc.cwt > conn.cwt {
			conn = sc
		}
	}
	if conn == nil {
		w.Unlock()
		return balancer.PickResult{}, balancer.ErrNoSubConnAvailable
	}
	conn.cwt -= totalWeight
	w.Unlock()
	if md, ok := metadata.FromContext(info.Ctx); ok {
		md["conn"] = conn
	}
	start := time.Now()
	done := func(doneInfo balancer.DoneInfo) {
		ev := int64(0)
		if doneInfo.Err != nil {
			ec := errors.ParseCode(doneInfo.Err)
			if ec.Internal() {
				ev = 1
			}
		}
		conn.err.Add(ev)
		now := time.Now()
		conn.latency.Add(now.Sub(start).Nanoseconds() / 1e5)
		u := atomic.LoadInt64(&w.updateAt)
		if now.UnixNano()-u < int64(time.Second) {
			return
		}

		if !atomic.CompareAndSwapInt64(&w.updateAt, u, now.UnixNano()) {
			return
		}
		var (
			count int
			total float64
		)
		for _, conn := range w.subConns {
			errc, reqc := conn.errSummary()
			lagv, lagc := conn.latencySummary()
			//applog.Info("wrr info", zap.Any("errc", errc), zap.Any("reqc", reqc), zap.Any("lagv", lagv),
			//	zap.Any("lagc", lagc))
			if reqc > 0 && lagc > 0 && lagv > 0 {
				cs := 1 - (float64(errc) / float64(reqc))
				if cs <= 0 {
					cs = 0.1
				} else if cs <= 0.2 && reqc <= 5 {
					cs = 0.2
				}
				//TODO
				conn.score = math.Sqrt((cs * 1e9) / (lagv))
			}

			if conn.score > 0 {
				total += conn.score
				count++
			}
		}

		if count < 2 {
			return
		}

		avgScore := total / float64(count)
		w.Lock()
		for _, conn := range w.subConns {
			if conn.score <= 0 {
				conn.score = avgScore
			}
			conn.ewt = int64(conn.score * float64(conn.wt))
			//applog.Info("conn ewt score", zap.Int64("id", conn.id), zap.Int64("ewt", conn.ewt),
			//	zap.Float64("score", conn.score))
		}
		w.Unlock()
	}
	//applog.Info("wrr pick", zap.Any("uid", conn.id))
	return balancer.PickResult{SubConn: conn.conn, Done: done}, nil
}
